### å‰è¨€

è¿™ä¸ªå’Œ`getPropertyValue` æœ‰å¾ˆå¤šç›¸ä¼¼çš„åœ°æ–¹ 

+ è§£æåµŒå¥—å±æ€§å¾—åˆ° `Accessor` 
+ ç”Ÿæˆ `token` å®é™…ä¸Šä¹Ÿå°±æ˜¯æ”¯æŒ `é›†åˆç±»å‹`
+ ç„¶åè°ƒç”¨ `AbstractNestablePropertyAccessor#setProperty`

`setPropertyValue`

```java
public void setPropertyValue(String propertyName, @Nullable Object value) throws BeansException{
		// [1] è·å–åµŒå¥—å±æ€§ä¸­çš„æœ€åä¸€ä¸ªAccessor
		AbstractNestablePropertyAccessor nestedPa;
		try {
			nestedPa = getPropertyAccessorForPropertyPath(propertyName);
		}
		catch (NotReadablePropertyException ex) {
			throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,
					"Nested property in path '" + propertyName + "' does not exist", ex);
		}
		// [2] ç”ŸæˆToken
		PropertyTokenHolder tokens = getPropertyNameTokens(getFinalPath(nestedPa, propertyName));

		// [3] æ ¹æ®Tokenè®¾ç½®å€¼
		nestedPa.setPropertyValue(tokens, new PropertyValue(propertyName, value));
}
```

æ˜¯ä¸æ˜¯ç¼ºå°‘äº† `PropertyHandler` ï¼Ÿï¼Œä¸ç”¨ç–‘é—®ï¼Œå› ä¸º`setProperty`æ”¯æŒ é€šç”¨ç±»å‹è½¬æ¢ï¼Œå¼ºå¾—ä¸€åŒ¹, æ‰€ä»¥ç±»å‹è½¬æ¢åæ‰éœ€è¦åˆ° `PropertyHandler`

ç»§ç»­è·Ÿ

```java
protected void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {
		if (tokens.keys != null) {
			// [1] å¤„ç†å¸¦key çš„å€¼, ç±»å‹å¯ä»¥æ˜¯ map,list,array
			processKeyedProperty(tokens, pv);
		}
		else {
			// [2] å¤„ç†ä¸å¸¦keyçš„å€¼,ä¹Ÿå°±æ˜¯æ™®é€šç±»å‹ï¼Œæˆ–è€…pojo
			processLocalProperty(tokens, pv);
		}
	}
```

**å¤„ç†å¸¦key** 

```java
xprivate void processKeyedProperty(PropertyTokenHolder tokens, PropertyValue pv) {
   // [1] è¿™é‡Œè·å–å±æ€§å€¼ï¼Œè¿™é‡Œæ˜¯setPropertyä¸ºä»€ä¹ˆè¦è·å–å€¼ï¼Ÿ
   // ç”¨äºåˆ¤æ–­å€¼çš„ç±»å‹
   Object propValue = getPropertyHoldingValue(tokens);x
```

å…ˆçœ‹ç¬¬ä¸€æ­¥ï¼Œè°ƒç”¨äº† `getPropertyHoldingValue` æ¥æ‹¿åˆ°å€¼

```java
private Object getPropertyHoldingValue(PropertyTokenHolder tokens) {

		// å› ä¸ºæˆ‘ä»¬æ˜¯è¦ setPropertyValue
		// beans[1]['fafaf']
		// æˆ‘ä»¬éœ€è¦å…ˆæ‹¿åˆ° beans[1]çš„å¯¹è±¡ï¼Œç„¶åæ‰èƒ½setValue
		// æ‰€ä»¥è¿™é‡Œï¼Œå®ƒåªcopyäº† tokens.keys.length -1 ä¸ªkeyï¼Œ æœ€åä¸€ä¸ªä¸éœ€è¦
		Assert.state(tokens.keys != null, "No token keys");
		PropertyTokenHolder getterTokens = new PropertyTokenHolder(tokens.actualName);
		getterTokens.canonicalName = tokens.canonicalName;
		getterTokens.keys = new String[tokens.keys.length - 1];
		System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);

		Object propValue;
		try {
			// call getPropertyValue , keys must be not null
			// propValue maybe is null
			propValue = getPropertyValue(getterTokens);
		}
		catch (NotReadablePropertyException ex) {
			throw new NotWritablePropertyException(getRootClass(), this.nestedPath + tokens.canonicalName,
					"Cannot access indexed value in property referenced " +
					"in indexed property path '" + tokens.canonicalName + "'", ex);
		}

		// å¦‚æœvalueä¸ºnullï¼Œåˆ™è¿™ä¸ªlastkeyå¯¹åº”çš„å±æ€§å¿…ç„¶æ˜¯ mapï¼Œå¯ä»¥çœ‹ getPropertyValue çš„ä»£ç ï¼Œé‡Œé¢æœ‰è§£æ
		if (propValue == null) {
			// map case
			// map[key][1]
			if (isAutoGrowNestedPaths()) {
				// è¿™ä¸ªæ—¶å€™ç»™ map è¿™ä¸ªå±æ€§è®¾ç½®é»˜è®¤å€¼ï¼Œ
				int lastKeyIndex = tokens.canonicalName.lastIndexOf('[');
				getterTokens.canonicalName = tokens.canonicalName.substring(0, lastKeyIndex);
				propValue = setDefaultValue(getterTokens);
			}
			else {
				throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + tokens.canonicalName,
						"Cannot access indexed value in property referenced " +
						"in indexed property path '" + tokens.canonicalName + "': returned null");
			}
		}
		return propValue;
	}
```

æ‹¿åˆ°å€¼åï¼Œæˆ‘ä»¬ç»§ç»­ 

```java
private void processKeyedProperty(PropertyTokenHolder tokens, PropertyValue pv) {
		// [1] è¿™é‡Œè·å–å±æ€§å€¼ï¼Œè¿™é‡Œæ˜¯setPropertyä¸ºä»€ä¹ˆè¦è·å–å€¼ï¼Ÿ
		// ç”¨äºåˆ¤æ–­å€¼çš„ç±»å‹
		Object propValue = getPropertyHoldingValue(tokens);
		
		// åœ¨è¿™é‡Œæ‹¿åˆ°Handler
		PropertyHandler ph = getLocalPropertyHandler(tokens.actualName);
		if (ph == null) {
			throw new InvalidPropertyException(
					getRootClass(), this.nestedPath + tokens.actualName, "No property handler found");
		}
		Assert.state(tokens.keys != null, "No token keys");
		// [TODO] å¦‚æœå±æ€§çš„å€¼æ˜¯ listç±»å‹å°±ä»£è¡¨ç´¢å¼•ï¼Œmapç±»å‹å°±æ˜¯key
		String lastKey = tokens.keys[tokens.keys.length - 1];

		/**
		 * [2] æ ¹æ®å±æ€§å€¼çš„ç±»å‹è¿›è¡Œè½¬æ¢ç„¶åè®¾ç½®å€¼
		 * é€šè¿‡è°ƒç”¨ {@link #convertIfNecessary(String, Object, Object, Class, TypeDescriptor)} æ¥è¿›è¡Œç±»å‹è½¬æ¢
		 */
		if (propValue.getClass().isArray()) {
			Class<?> requiredType = propValue.getClass().getComponentType();

			// [DESC] å±æ€§ç±»å‹ä¸ºæ•°ç»„ï¼Œåˆ™keyä»£è¡¨ç´¢å¼•
			int arrayIndex = Integer.parseInt(lastKey);
			Object oldValue = null;
			try {
				if (isExtractOldValueForEditor() && arrayIndex < Array.getLength(propValue)) {
					oldValue = Array.get(propValue, arrayIndex);
				}
				// è¿›è¡Œç±»å‹è½¬æ¢
				Object convertedValue = convertIfNecessary(tokens.canonicalName, oldValue, pv.getValue(),
						requiredType, ph.nested(tokens.keys.length));
				// è·å–å½“å‰å±æ€§æ•°ç»„é•¿åº¦,åˆ¤æ–­æ˜¯å¦è¶Šç•Œ
				int length = Array.getLength(propValue);
				if (arrayIndex >= length && arrayIndex < this.autoGrowCollectionLimit) {
					// å¦‚æœå½“å‰å±æ€§é•¿åº¦ä¸è¶³ï¼Œåˆ™newä¸€ä¸ªï¼Œç„¶åcopy
					Class<?> componentType = propValue.getClass().getComponentType();
					Object newArray = Array.newInstance(componentType, arrayIndex + 1);
					System.arraycopy(propValue, 0, newArray, 0, length);

					// ç„¶åè®¾ç½®å±æ€§å€¼
					setPropertyValue(tokens.actualName, newArray);
					propValue = getPropertyValue(tokens.actualName);
				}
				// æœ€åæ‰å°†æ•°æ®ä¸¢è¿›æ•°ç»„
				Array.set(propValue, arrayIndex, convertedValue);
			}
			catch (IndexOutOfBoundsException ex) {
				throw new InvalidPropertyException(getRootClass(), this.nestedPath + tokens.canonicalName,
						"Invalid array index in property path '" + tokens.canonicalName + "'", ex);
			}
		}

		else if (propValue instanceof List) {
			Class<?> requiredType = ph.getCollectionType(tokens.keys.length);
			List<Object> list = (List<Object>) propValue;
			// [DESC] å±æ€§ç±»å‹ä¸ºlistï¼Œåˆ™keyä»£è¡¨ç´¢å¼•
			int index = Integer.parseInt(lastKey);
			Object oldValue = null;
			if (isExtractOldValueForEditor() && index < list.size()) {
				oldValue = list.get(index);
			}

			// æ•°æ®è½¬æ¢
			Object convertedValue = convertIfNecessary(tokens.canonicalName, oldValue, pv.getValue(),
					requiredType, ph.nested(tokens.keys.length));

			// åˆ¤æ–­ä¸‹è¡¨æ˜¯å¦è¶Šç•Œ
			int size = list.size();
			if (index >= size && index < this.autoGrowCollectionLimit) {
				// æ¯”å¦‚å½“å‰å±æ€§listæœ‰5ä¸ªå…ƒç´ ï¼Œè‹¥è¦æ’å…¥ä½ç½®ä¸º8ï¼Œåˆ™å…¶ä½™çš„å¡«å……ä¸º null
				for (int i = size; i < index; i++) {
					try {
						list.add(null);
					}
					catch (NullPointerException ex) {
						throw new InvalidPropertyException(getRootClass(), this.nestedPath + tokens.canonicalName,
								"Cannot set element with index " + index + " in List of size " +
								size + ", accessed using property path '" + tokens.canonicalName +
								"': List does not support filling up gaps with null elements");
					}
				}
				// æ·»åŠ è¿›list
				list.add(convertedValue);
			}
			else {
				try {
					// æ·»åŠ è¿›list
					list.set(index, convertedValue);
				}
				catch (IndexOutOfBoundsException ex) {
					throw new InvalidPropertyException(getRootClass(), this.nestedPath + tokens.canonicalName,
							"Invalid list index in property path '" + tokens.canonicalName + "'", ex);
				}
			}
		}

		else if (propValue instanceof Map) {
			// [DESC] å±æ€§ç±»å‹ä¸ºmapåˆ™ keyå°±ä¸º mapçš„key
			Class<?> mapKeyType = ph.getMapKeyType(tokens.keys.length);
			Class<?> mapValueType = ph.getMapValueType(tokens.keys.length);
			Map<Object, Object> map = (Map<Object, Object>) propValue;
			// IMPORTANT: Do not pass full property name in here - property editors
			// must not kick in for map keys but rather only for map values.

			// [DESC] keyçš„ç±»å‹ä¹Ÿéœ€è¦è½¬æ¢ä¸€ä¸‹
			TypeDescriptor typeDescriptor = TypeDescriptor.valueOf(mapKeyType);
			Object convertedMapKey = convertIfNecessary(null, null, lastKey, mapKeyType, typeDescriptor);
			Object oldValue = null;

			// ç„¶åæ ¹æ®keyè·å–mapä¸­çš„å€¼
			if (isExtractOldValueForEditor()) {
				oldValue = map.get(convertedMapKey);
			}
			// Pass full property name and old value in here, since we want full
			// conversion ability for map values.
			// å†å°†æ•°æ®è½¬æ¢ä¸ºmap[key]å¯¹è±¡å¯¹åº”çš„ç±»å‹
			Object convertedMapValue = convertIfNecessary(tokens.canonicalName, oldValue, pv.getValue(),
					mapValueType, ph.nested(tokens.keys.length));
			// æœ€åè®¾ç½®mapçš„å€¼
			map.put(convertedMapKey, convertedMapValue);
		}

		else {
			throw new InvalidPropertyException(getRootClass(), this.nestedPath + tokens.canonicalName,
					"Property referenced in indexed property path '" + tokens.canonicalName +
					"' is neither an array nor a List nor a Map; returned value was [" + propValue + "]");
		}
	}
```

å¤„ç†å¸¦keyçš„éƒ¨åˆ†ç¡®å®å¾ˆå¤æ‚ï¼Œå› ä¸ºè¦è€ƒè™‘å¾ˆå¤šç§ç±»å‹ï¼Œ`list` ã€`array` ã€`map` ï¼Œå¦‚æœå±æ€§ä¸ºç©ºè¿˜å¾—æ‰©å®¹ï¼Œè®¾ç½®å±æ€§å€¼çš„æ—¶å€™è¿˜è¦æ”¯æŒç±»å‹è½¬æ¢ï¼Œä¸‹é¢æ¥çœ‹ å¤„ç†ä¸å¸¦key çš„éƒ¨åˆ†

```java
private void processLocalProperty(PropertyTokenHolder tokens, PropertyValue pv) {
		// [1] å…ˆè·å–handler
		PropertyHandler ph = getLocalPropertyHandler(tokens.actualName);
		if (ph == null || !ph.isWritable()) {
			if (pv.isOptional()) {
				if (logger.isDebugEnabled()) {
					logger.debug("Ignoring optional value for property '" + tokens.actualName +
							"' - property not found on bean class [" + getRootClass().getName() + "]");
				}
				return;
			}
			else {
				throw createNotWritablePropertyException(tokens.canonicalName);
			}
		}

		// [2] ç›´æ¥è½¬æ¢ç±»å‹
		Object oldValue = null;
		try {
			Object originalValue = pv.getValue();
			Object valueToApply = originalValue;
			if (!Boolean.FALSE.equals(pv.conversionNecessary)) {
				// å°è¯•ä»ç¼“å­˜ä¸­æ‹¿åˆ°è½¬æ¢çš„å€¼
				if (pv.isConverted()) {
					valueToApply = pv.getConvertedValue();
				}
				else {
					if (isExtractOldValueForEditor() && ph.isReadable()) {
						// è°ƒç”¨ getæ–¹æ³•æ‹¿åˆ°å±æ€§å€¼
						try {
							oldValue = ph.getValue();
						}
						catch (Exception ex) {
							if (ex instanceof PrivilegedActionException) {
								ex = ((PrivilegedActionException) ex).getException();
							}
							if (logger.isDebugEnabled()) {
								logger.debug("Could not read previous value of property '" +
										this.nestedPath + tokens.canonicalName + "'", ex);
							}
						}
					}
					// ç±»å‹è½¬æ¢
					valueToApply = convertForProperty(
							tokens.canonicalName, oldValue, originalValue, ph.toTypeDescriptor());
				}
				// è®¾ç½® flagï¼Œç¡®è®¤æ˜¯å¦éœ€è¦è½¬æ¢ï¼Œå¦‚æœæ˜¯åŒç±»å‹çš„ä¸‹æ¬¡å°±ä¸ç”¨è½¬æ¢äº†
				pv.getOriginalPropertyValue().conversionNecessary = (valueToApply != originalValue);
			}
			
			// è°ƒç”¨ setæ–¹æ³•è®¾ç½®å±æ€§å€¼ 
			ph.setValue(valueToApply);
		}
		catch (TypeMismatchException ex) {
			throw ex;
		}
		catch (InvocationTargetException ex) {
			PropertyChangeEvent propertyChangeEvent = new PropertyChangeEvent(
					getRootInstance(), this.nestedPath + tokens.canonicalName, oldValue, pv.getValue());
			if (ex.getTargetException() instanceof ClassCastException) {
				throw new TypeMismatchException(propertyChangeEvent, ph.getPropertyType(), ex.getTargetException());
			}
			else {
				Throwable cause = ex.getTargetException();
				if (cause instanceof UndeclaredThrowableException) {
					// May happen e.g. with Groovy-generated methods
					cause = cause.getCause();
				}
				throw new MethodInvocationException(propertyChangeEvent, cause);
			}
		}
		catch (Exception ex) {
			PropertyChangeEvent pce = new PropertyChangeEvent(
					getRootInstance(), this.nestedPath + tokens.canonicalName, oldValue, pv.getValue());
			throw new MethodInvocationException(pce, ex);
		}
	}
```

å¤„ç†ä¸å¸¦keyçš„å¾ˆç®€å•ï¼Œå°±è½¬æ¢ä¸€ä¸‹æ•°æ®ç±»å‹ï¼Œç„¶åè°ƒç”¨ `set `æ–¹æ³•è®¾ç½®å±æ€§å€¼å°±ğŸ‘Œï¼Œç±»å‹è½¬æ¢ä¼šå•ç‹¬è·³å‡ºæ¥åˆ†æï¼Œå› ä¸ºè¿™äº›ä¸œè¥¿éƒ½æ¯”è¾ƒå¤æ‚.