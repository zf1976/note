### 1.å‰è¨€

ä¸ºä»€ä¹ˆå…ˆä»å¯¹beançš„åŒ…è£…å¼€å§‹é˜…è¯»æºç å‘¢ï¼Œå› ä¸ºbeansåŒ…çš„æ ¸å¿ƒå°±æ˜¯`BeanFactory` ğŸ¶ï¼Œå…¶ä½œç”¨å°±æ˜¯å¯¹beanè¿›è¡Œç®¡ç†ï¼Œé‚£ä¹ˆå¯¹beanç®¡ç†çš„å‰æå°±æ˜¯å¯¹beanè¿›è¡Œè§£æï¼Œç„¶åæ”¯æŒå±æ€§çš„`set` æˆ– `get` æ“ä½œã€‚é‚£ä¹ˆæˆ‘ä»¬åˆ—ä¸¾ä¸€ä¸‹`BeanFactory`çš„ä¸»è¦èŒè´£ï¼Œå³ä½¿æ²¡é˜…è¯»è¿‡æºç ï¼Œä¹Ÿåº”è¯¥çŸ¥é“ä¸ªå¤§æ¦‚è¿‡ç¨‹.

+ è§£æ`xml`æˆ–è€…å…¶å®ƒé…ç½®æ–‡ä»¶å¾—åˆ° `BeanDefinition`
+ å®ä¾‹åŒ– `Instance`
+ `AutoWired`è‡ªåŠ¨è£…é… `Bean`çš„ä¾èµ–

**æ‰€ä»¥ï¼Œæˆ‘ä»¬å…ˆäº†è§£å¦‚ä½•å»å¾—åˆ°ä¸€ä¸ªBeançš„ â€œå®šä¹‰â€ (è§£æxmlé‚£éƒ¨åˆ†å…ˆä¸è®²)**

### 2. BeanWrapperæ¥å£

```tex
è¿™ä¸ªç±»çš„ä¸»è¦ä½œç”¨æ˜¯è§£æ`Class` ç„¶åè·å–å±æ€§ï¼Œè¿›ä¸€æ­¥å°è£…ï¼Œç„¶åæä¾›ä¿®æ”¹å±æ€§çš„æ¥å£
```

```java
public interface BeanWrapper extends ConfigurablePropertyAccessor {
  // è®¾ç½®é›†åˆå±æ€§è‡ªå¢é•¿çš„é•¿åº¦
	void setAutoGrowCollectionLimit(int autoGrowCollectionLimit);
	
  // è·å–å½“å‰é›†åˆå±æ€§è‡ªå¢é•¿çš„é•¿åº¦
	int getAutoGrowCollectionLimit();
	
	// è·å–åŒ…è£…çš„Beançš„Instance
	Object getWrappedInstance();
	
	// è·å–Beançš„Class
	Class<?> getWrappedClass();
	
	// è·å–æ‰€æœ‰å±æ€§æè¿°ç¬¦
	PropertyDescriptor[] getPropertyDescriptors();
  
  // è·å–å±æ€§æè¿°ç¬¦
	PropertyDescriptor getPropertyDescriptor(String propertyName) throws InvalidPropertyException;

}
```



ä¸ºä»€ä¹ˆä¸Šé¢ä¼šæ¶‰åŠåˆ°**é›†åˆ**ï¼Œå› ä¸º`Bean` æ”¯æŒ`nested (åµŒå¥—)` å±æ€§è¯»å†™ï¼Œä¹Ÿå°±æ˜¯`pojo`

```properties
bean.setValue("bean.child.attr", 1)
```

### 3. `BeanWrapperImplå®ç°`

1. æˆ‘ä»¬ä»å…¶æµ‹è¯•ä»£ç ä¸­å¯ä»¥çœ‹åˆ°è¿™æ ·çš„ç”¨æ³•

   

   ```java
   GetterBean target = new GetterBean();
   BeanWrapper accessor = createAccessor(target);
   accessor.setPropertyValue("name", "tom");
   assertThat(target.getAliasedName()).isEqualTo("tom");
   assertThat(accessor.getPropertyValue("aliasedName")).isEqualTo("tom");
   ```

   ```java
   protected BeanWrapperImpl createAccessor(Object target) {
   		return new BeanWrapperImpl(target);
   	}
   ```

   æˆ‘ä»¬å¯ä»¥çœ‹åˆ° `createAccessor` å°±æ˜¯`new BeanWrapperImpl`å°±å®Œæˆå¯¹`Bean`çš„å°è£…äº†ï¼Œ å°±å¯ä»¥è°ƒç”¨

   - `setPropertyValue`  è®¾ç½®å±æ€§å€¼
   - `getPropertyValue`  è·å–å±æ€§å€¼

2. åˆæ­¥çœ‹ä¸‹ `BeanWrapperImpl`çš„`UML` (ä¸ç”¨çº ç»“ `UML` åé¢ä¼šäººè‚‰å…¶è¿è¡Œè¿‡ç¨‹) :happy:

   

   ![image-20191012223223606](img/image-20191012223223606.png)

   
   
   **åœ¨ä¸Šé¢è¿™ä¸ªå›¾ä¸­ï¼Œç€é‡ `AbstractNesablePropertyAccessor`** æ­¤ç±»æ˜¯ç”¨äºæ”¯æŒä¸Šæ–‡æåˆ°çš„`Nested` åµŒå¥—å±æ€§è¯»å†™.
   
3. `getPropertyDescriptor` è·å–å±æ€§æè¿°ç¬¦

   ```java
   public PropertyDescriptor getPropertyDescriptor(String propertyName) throws InvalidPropertyException {
   		// [1] å…ˆè§£æåµŒå¥—å±æ€§ï¼Œè·å–æœ€åä¸€ä¸ªå±æ€§çš„Instance
   		BeanWrapperImpl nestedBw = (BeanWrapperImpl) getPropertyAccessorForPropertyPath(propertyName);
   		String finalPath = getFinalPath(nestedBw, propertyName);
   		// [2] ç„¶åç›´æ¥è·å–å±æ€§æè¿°ç¬¦
   		PropertyDescriptor pd = nestedBw.getCachedIntrospectionResults().getPropertyDescriptor(finalPath);
   		if (pd == null) {
   			throw new InvalidPropertyException(getRootClass(), getNestedPath() + propertyName,
   					"No property '" + propertyName + "' found");
   		}
   		return pd;
   	}
   ```

   + åˆšæ‰æˆ‘ä»¬è¯´è¿‡å…¶æ”¯æŒ`nested` åµŒå¥—å±æ€§ï¼Œå¦‚æœæˆ‘ä»¬ä¼ å…¥çš„`propertyName` ä¸º `bean.child.name` ï¼Œæˆ‘ä»¬å°±è¦å…ˆæ‹¿åˆ° `bean` ç„¶åå†æ‹¿åˆ° `child` æœ€åæ‹¿åˆ° `name` ç„¶åæ‰èƒ½è¿”å›ç±»å‹æè¿°ç¬¦. â€‹ :warning: ç¬¬ä¸€æ­¥æˆ‘ä»¬å…ˆä¸ç®¡

   + ç„¶åç¬¬äºŒæ­¥ `getCachedIntrospectionResults#getPropertyDescriptor()` æ¥è·å–å±æ€§æè¿°ç¬¦

   + `CachedIntrospectionResults` ä¸­åŒ…å« `PropertyDescriptor` ä¿¡æ¯ï¼Œè·Ÿä¸‹å»

     

     ```java
     private CachedIntrospectionResults getCachedIntrospectionResults() {
        	// [1] åˆ¤æ–­æ˜¯ä¸æ˜¯æœ‰ç¼“å­˜äº†
     		if (this.cachedIntrospectionResults == null) {
           // [2] ç¼“å­˜ä¸­æ²¡æœ‰é‚£å°± new
     			this.cachedIntrospectionResults = CachedIntrospectionResults.forClass(getWrappedClass());
     		}
     		return this.cachedIntrospectionResults;
     	}
     ```

     ç»§ç»­è·Ÿã€‚

     ```java
     static CachedIntrospectionResults forClass(Class<?> beanClass) throws BeansException {
     		// [1] ä»ä¸€çº§ç¼“å­˜ä¸­è·å–
     		CachedIntrospectionResults results = strongClassCache.get(beanClass);
     		if (results != null) {
     			return results;
     		}
     
     		// [2] ä»äºŒçº§ç¼“å­˜ä¸­è·å–
     		results = softClassCache.get(beanClass);
     		if (results != null) {
     			return results;
     		}
     
     		// [3] å¦‚æœéƒ½æ²¡æœ‰ï¼Œåˆ™Newä¸€ä¸ª, æ ¸å¿ƒè¿˜æ˜¯åœ¨è¿™
     		results = new CachedIntrospectionResults(beanClass);
     		ConcurrentMap<Class<?>, CachedIntrospectionResults> classCacheToUse;
     
     		// [4] åˆ¤æ–­ä½¿ç”¨ä¸€çº§ç¼“å­˜è¿˜æ˜¯äºŒçº§ç¼“å­˜
     		// ç»è°ƒè¯•ï¼Œå‘ç°springç”¨çš„æ˜¯ä¸€çº§ç¼“å­˜
     		if (ClassUtils.isCacheSafe(beanClass, CachedIntrospectionResults.class.getClassLoader()) ||
     				isClassLoaderAccepted(beanClass.getClassLoader())) {
     			classCacheToUse = strongClassCache;
     		}
     		else {
     			if (logger.isDebugEnabled()) {
     				logger.debug("Not strongly caching class [" + beanClass.getName() + "] because it is not cache-safe");
     			}
     			classCacheToUse = softClassCache;
     		}
     
     		// [5] å°†æ–°Newçš„æ”¾å…¥ç¼“å­˜
     		CachedIntrospectionResults existing = classCacheToUse.putIfAbsent(beanClass, results);
     		return (existing != null ? existing : results);
     	}
     ```

     å¯ä»¥çœ‹åˆ°`spring` å¾ˆå–„ç”¨ç¼“å­˜ï¼Œè¿™é‡Œå¯ä»¥çœ‹åˆ°ï¼Œå…¶ç”¨äº†ä¸¤ä¸ªç¼“å­˜ `strongClassCache` å’Œ `softClassCache`

     ```java
       /* [DESC] ä¸€çº§ç¼“å­˜*/
     	static final ConcurrentMap<Class<?>, CachedIntrospectionResults> strongClassCache =
     			new ConcurrentHashMap<>(64);
     
     	/* [DESC] äºŒçº§ç¼“å­˜ åˆç§°ä¸º SoftCacheï¼Œå› ä¸ºé‡‡ç”¨å¼±å¼•ç”¨MAPï¼Œæ‰€ä»¥ç¼“å­˜å…ƒç´ é•¿æ—¶é—´æœªä½¿ç”¨åˆ™ä¼šè¢«å›æ”¶*/
     	static final ConcurrentMap<Class<?>, CachedIntrospectionResults> softClassCache =
     			new ConcurrentReferenceHashMap<>(64);
     ```

     **è™½ç„¶å…¶è®¾ç½®äº†ä¸¤å±‚ç¼“å­˜ï¼Œä½†å®é™…åªç”¨åˆ°äº† `strongClassCache`** å› ä¸ºå±æ€§è¿™äº›ä¼šå¸¸é©»å†…å­˜ï¼Œæ‰€ä»¥ä¸éœ€è¦ä½¿ç”¨å¼±å¼•ç”¨çš„`Map`,å®é™…ä¸Šæ§åˆ¶ä½¿ç”¨é‚£ä¸ªç¼“å­˜æ˜¯`isCacheSafe` æ¥æ§åˆ¶çš„, ç»§ç»­è·Ÿ :hammer:æˆ‘æ˜¯æœ€å¼ºäººè‚‰ç‹å­

     ```java
     public static boolean isCacheSafe(Class<?> clazz, @Nullable ClassLoader classLoader) {
        Assert.notNull(clazz, "Class must not be null");
        try {
           // [1] è·å–è¯¥ç±»çš„ClassLoader
           ClassLoader target = clazz.getClassLoader();
           // Common cases
     
           // [2] å¦‚æœç›®æ ‡ç±»çš„ClassLoader == æä¾›çš„classLoader
           // [NOTICE] åŒäº²å§”æ´¾åŸåˆ™ï¼Œåªæœ‰ä½¿ç”¨åŒä¸€ä¸ªç±»åŠ è½½å™¨ï¼ŒåŠ è½½çš„æ•°æ®æ‰èƒ½æ˜¯åªæœ‰ä¸€ä»½ï¼Œè¿™ä¸ªç¼“å­˜æ‰æ˜¯æ˜¯æœ‰æ•ˆçš„
           if (target == classLoader || target == null) {
              return true;
           }
           if (classLoader == null) {
              return false;
           }
           // [3] é€’å½’classLoaderçš„ç¥–å…ˆ
           // Check for match in ancestors -> positive
           ClassLoader current = classLoader;
           while (current != null) {
              current = current.getParent();
              if (current == target) {
                 return true;
              }
           }
           
           // [4] é€’å½’ç›®æ ‡çš„ç¥–å…ˆ
           // Check for match in children -> negative
           while (target != null) {
              target = target.getParent();
              if (target == classLoader) {
                 return false;
              }
           }
        }
        catch (SecurityException ex) {
           // Fall through to loadable check below
        }
     
        // Fallback for ClassLoaders without parent/child relationship:
        // safe if same Class can be loaded from given ClassLoader
        return (classLoader != null && isLoadable(clazz, classLoader));
     }
     ```

     **è¿™é‡Œåˆ¤æ–­cacheæ˜¯å¦å®‰å…¨çš„åŸç†æ˜¯** ï¼Œæ ¹æ®`åŒäº²å§”æ´¾` æœºåˆ¶ï¼Œå› ä¸ºä¸€ä¸ªç±»è¢«ä¸€ä¸ªåŠ è½½å™¨åŠ è½½ä¸€æ¬¡åœ¨å†…å­˜ä¸­å°±ä¼šæœ‰ä¸€ä»½`Class` , å¦‚æœå®ƒä»¬çš„åŠ è½½å™¨æ˜¯ä¸€æ ·çš„ï¼Œé‚£ä¹ˆå¾—åˆ°çš„`Class` ä¹Ÿæ˜¯ä¸€è‡´çš„ï¼Œè¿™æ ·æ‰èƒ½ç¡®ä¿ï¼Œæˆ‘ä»¬æ‹¿åˆ°çš„ç›®æ ‡`Class` æ•°æ®æ˜¯æ­£ç¡®çš„ã€‚

     è§£æå®Œè¿™ä¸ªï¼Œæˆ‘ä»¬ç»§ç»­ä¸Šé¢çš„ï¼Œå¦‚æœä»ç¼“å­˜æ‹¿ä¸åˆ°åˆ™ `new`

     ```java
     results = new CachedIntrospectionResults(beanClass);
     ```

     ```java
     private CachedIntrospectionResults(Class<?> beanClass) throws BeansException {
     		try {
     			if (logger.isTraceEnabled()) {
     				logger.trace("Getting BeanInfo for class [" + beanClass.getName() + "]");
     			}
     			// å…³æ³¨ #getBeanInfo
     			this.beanInfo = getBeanInfo(beanClass);
     ```

     ```java
     private static BeanInfo getBeanInfo(Class<?> beanClass) throws IntrospectionException {
        // [1] å°è¯•ä»åŠ è½½çš„å·¥å‚ä¸­è·å–BeanInfo
        // å®é™…ä¸Šï¼Œspring.beans åªæä¾›ä¸€ä¸ªå·¥å‚ï¼Œè€Œä¸”é‚£ä¸ªå·¥å‚ä¹Ÿæ˜¯ä»çº¿ç¨‹ä¸Šä¸‹æ–‡ä¸­è·å–
        // æ‰€ä»¥ä¸€å®šèƒ½æ‹¿åˆ°ï¼Œè¿™æ˜¯ä¸ºäº†é˜²æ­¢spring.beansæ²¡æœ‰æä¾›å·¥å‚è€Œè€ƒè™‘åˆ°çš„ç»†èŠ‚
        for (BeanInfoFactory beanInfoFactory : beanInfoFactories) {
           BeanInfo beanInfo = beanInfoFactory.getBeanInfo(beanClass);
           if (beanInfo != null) {
              return beanInfo;
           }
        }
     
        // [2] å¦‚æœä¸æä¾›å·¥å‚æˆ–è€…å·¥å‚ä¸å­˜åœ¨ï¼Œç›´æ¥åœ¨çº¿ç¨‹ä¸Šä¸‹æ–‡ä¸­è·å–
        return (shouldIntrospectorIgnoreBeaninfoClasses ?
              Introspector.getBeanInfo(beanClass, Introspector.IGNORE_ALL_BEANINFO) :
              Introspector.getBeanInfo(beanClass));
     }
     ```

     åœ¨`CachedIntrospectionResults` ä¸­ï¼Œå®ƒä¼šåŠ è½½ä¸€ä¸ª `factory`

     ```java
     /** [DESC]  åœ¨è¿™é‡ŒåŠ è½½BeanInfoFactory*/
     // åŠ è½½ "META-INF/spring.factories" ä¸­æŒ‡å®šçš„å·¥å‚ç±»
     private static List<BeanInfoFactory> beanInfoFactories = SpringFactoriesLoader.loadFactories(
           BeanInfoFactory.class, CachedIntrospectionResults.class.getClassLoader());
     ```

     ```properties
     org.springframework.beans.BeanInfoFactory=org.springframework.beans.ExtendedBeanInfoFactory
     ```

     å‘ç°äº†ï¼Œå®ƒçš„é»˜è®¤å·¥å‚ç±»æ˜¯ `ExtendedBeanInfoFactory`

     æ¥ä¸‹æ¥ç»§ç»­çœ‹ï¼Œå¦‚æœå·¥å‚ç±»ä¸­ä¸å­˜åœ¨ `BeanInfo`åˆ™ä¼šè°ƒç”¨ `Introspector#getBeanInfo()`

     ```java
     public static BeanInfo getBeanInfo(Class<?> beanClass)
             throws IntrospectionException
         {
             if (!ReflectUtil.isPackageAccessible(beanClass)) {
                 return (new Introspector(beanClass, null, USE_ALL_BEANINFO)).getBeanInfo();
             }
       			// ä»çº¿ç¨‹ä¸Šä¸‹æ–‡è·å–å·²ç»åŠ è½½çš„ Class ä¿¡æ¯
             ThreadGroupContext context = ThreadGroupContext.getContext();
             BeanInfo beanInfo;
             synchronized (declaredMethodCache) {
                 beanInfo = context.getBeanInfo(beanClass);
             }
             if (beanInfo == null) {
                 beanInfo = new Introspector(beanClass, null, USE_ALL_BEANINFO).getBeanInfo();
                 synchronized (declaredMethodCache) {
                     context.putBeanInfo(beanClass, beanInfo);
                 }
             }
             return beanInfo;
         }
     ```

     åˆ°æ­¤å°±ä¸ç”¨è¿½äº†ï¼Œè¿™é‡Œå·²ç»æ˜¯jdkäº†ï¼Œå®é™…ä¸Šæ˜¯ä» `çº¿ç¨‹ä¸Šä¸‹æ–‡`è·å–çš„ `BeanInfo` ï¼Œè¿™ä¹Ÿè¯æ˜äº† `BeanFactory` ç”¨çš„æ˜¯ `çº¿ç¨‹ä¸Šä¸‹æ–‡åŠ è½½å™¨` 

     **å…¶å®ä¸Šé¢çš„ é»˜è®¤å·¥å‚ ExtendedBeanInfoFactory** ç”¨çš„ä¹Ÿæ˜¯`ä¸Šä¸‹æ–‡åŠ è½½å™¨`

     ```java
     public class ExtendedBeanInfoFactory implements BeanInfoFactory, Ordered {
     
        /**
         * Return an {@link ExtendedBeanInfo} for the given bean class, if applicable.
         */
        @Override
        @Nullable
        public BeanInfo getBeanInfo(Class<?> beanClass) throws IntrospectionException {
           return (supports(beanClass) ? new ExtendedBeanInfo(Introspector.getBeanInfo(beanClass)) : null);
        }
     ```

     **æ€»ç»“ä¸‹ï¼Œä»¥å…è·Ÿå¾—å¤ªæ·±ï¼Œå›æº¯ä¸äº†**

     ![image-20191013012133042](img/image-20191013012133042.png)

     

     **ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬ä¹Ÿåªæ˜¯æ‹¿åˆ°äº† `BeanInfo`**

     å›åˆ° `new CachedIntrospectionResults` çš„åœ°æ–¹ï¼Œæˆ‘ä»¬é¦–å…ˆå·²ç»æœ‰äº† `BeanInfo`

     ```java
     private CachedIntrospectionResults(Class<?> beanClass) throws BeansException {
        try {
           // å…³æ³¨ #getBeanInfo
           this.beanInfo = getBeanInfo(beanClass);
     
           this.propertyDescriptorCache = new LinkedHashMap<>();
     
           // [1] ç›´æ¥è·å–BeanInfoçš„ {@link PropertyDescriptor}
           PropertyDescriptor[] pds = this.beanInfo.getPropertyDescriptors();
           for (PropertyDescriptor pd : pds) {
              // [2] æŸäº›å±æ€§æ˜¯è¢«ä¿æŠ¤çš„ï¼Œåˆ™è·³è¿‡
              if (Class.class == beanClass &&
                    ("classLoader".equals(pd.getName()) ||  "protectionDomain".equals(pd.getName()))) {
                 continue;
              }
              // [3] å°†{@link PropertyDescriptor} è½¬æ¢ä¸º {@link GenericTypeAwarePropertyDescriptor}
              pd = buildGenericTypeAwarePropertyDescriptor(beanClass, pd);
              // [4] ä¸¢å…¥ç¼“å­˜
              this.propertyDescriptorCache.put(pd.getName(), pd);
           }
     
           // [5] è¿˜å¾—åˆ¤æ–­è¿™äº›æ–¹æ³•æ˜¯ä¸æ˜¯java8çš„æ¥å£çš„é»˜è®¤æ–¹æ³•
           Class<?> currClass = beanClass;
           while (currClass != null && currClass != Object.class) {
              introspectInterfaces(beanClass, currClass);
              currClass = currClass.getSuperclass();
           }
           this.typeDescriptorCache = new ConcurrentReferenceHashMap<>();
        }
        
     }
     ```

     ç›´æ¥ä» `BeanInfo` æ‹¿åˆ°å±æ€§æè¿°ç¬¦ï¼Œå¹¶ä¸”ç¼“å­˜èµ·æ¥ï¼Œç°åœ¨æˆ‘ä»¬å°±å®Œæˆäº†è·å– `BeanInfo` éƒ¨åˆ†äº†ï¼Œé‚£ä¹ˆå‰©ä¸‹çš„å°±æ˜¯æ ¹æ®æ‹¿åˆ°çš„ `PropertyDescriptor` å»è¯»å†™ `Property` :wink:

   














